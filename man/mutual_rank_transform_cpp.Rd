% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{mutual_rank_transform_cpp}
\alias{mutual_rank_transform_cpp}
\title{Streaming mutual rank transformation (memory-efficient, parallelized)}
\usage{
mutual_rank_transform_cpp(sim_pcc, n_cores = 1L)
}
\arguments{
\item{sim_pcc}{Symmetric Pearson correlation matrix (n x n)}

\item{n_cores}{Number of OpenMP threads to use (default: 1)}
}
\value{
Mutual rank normalized similarity matrix (n x n) with values in range 0 to 1
}
\description{
Transforms a Pearson correlation matrix into a PCC+MR similarity matrix
using the mutual rank normalization from Obayashi & Kinoshita (2009).
}
\details{
This implementation uses a streaming approach that computes ranks on-demand
for each row pair, avoiding storage of intermediate rank matrices.
The algorithm is fully parallelizable via OpenMP.

Memory usage: O(n^2) for input + O(n^2) for output + O(n) per thread
Time complexity: O(n^3) due to on-demand rank computation

The transformation is:
\deqn{S^{PCC+MR}_{ij} = 1 - \frac{\log(\sqrt{R_{ij} \cdot R_{ji}})}{\log(n)}}

Where R_ij is the rank of gene j in gene i's correlation row (descending order).

Since the input PCC matrix is symmetric, we exploit that colRanks(i,j) = rowRanks(j,i).
This means we only need to compute row ranks for each row.
}
