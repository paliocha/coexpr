% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/similarity.R
\name{calculate_pcc_mr}
\alias{calculate_pcc_mr}
\title{Calculate PCC+MR similarity matrix}
\usage{
calculate_pcc_mr(
  expr_matrix,
  method = c("pcc_mr", "pcc"),
  n_cores = 1,
  chunk_size = NULL,
  mr_method = c("cached", "streaming"),
  return_tri = TRUE
)
}
\arguments{
\item{expr_matrix}{Numeric matrix of gene expression (genes × samples).
Rows are genes, columns are samples. Should be log-transformed.}

\item{method}{Character. Either "pcc_mr" (default, recommended) for Pearson
correlation with mutual rank, or "pcc" for Pearson only.}

\item{n_cores}{Integer. Number of cores for parallel mutual rank computation
via OpenMP. Default is 1 (sequential).}

\item{chunk_size}{Deprecated. No longer used (kept for API compatibility).}

\item{mr_method}{Character. Method for mutual rank computation:
\itemize{
\item "cached" (default): Precomputes all row ranks, faster but uses more memory
(O(n^2) for rank matrix). Recommended for most cases.
\item "streaming": Computes ranks on-demand, slower but more memory-efficient.
Use for very large matrices that cause memory issues with "cached".
}}

\item{return_tri}{Logical. If TRUE (default), returns a TriSimilarity object
that stores only the upper triangle for ~50\% memory savings. If FALSE,
returns a full symmetric matrix. Note: CCS calculation works with both formats.}
}
\value{
If return_tri = TRUE (default), a TriSimilarity object.
If return_tri = FALSE, a symmetric similarity matrix (genes × genes).
Values are in the range 0 to 1. Higher values indicate stronger co-expression.
}
\description{
Calculates co-expression similarity using Pearson correlation followed by
mutual rank normalization (Obayashi et al. 2009). This is the best-performing
method identified in Grønvold & Hvidsten for cross-species comparisons.
}
\details{
The PCC+MR method:
\enumerate{
\item Calculates Pearson correlation: S^PCC_ij = cor(E_i, E_j)
\item Transforms using log mutual rank: S^(PCC+MR)_ij = 1 - log(sqrt(R_ij * R_ji)) / log(n)
}

Where R_ij is the rank of S^PCC_ij in row i (ordered high to low).
The log transformation emphasizes strong correlations and the mutual rank
reduces bias from large co-expression clusters.
\subsection{Triangular Storage}{

By default, the function returns a TriSimilarity object that stores only
the upper triangle of the symmetric matrix. This reduces memory usage by
approximately 50\%. Use \code{as.matrix()} to convert to a full matrix if needed.
}

\subsection{Mutual Rank Methods}{

The mutual rank transformation is implemented in C++ for efficiency:
\itemize{
\item \strong{cached}: O(n^2 log n) time, O(n^2) extra memory. Precomputes all row
ranks before computing mutual ranks. Much faster for typical datasets.
\item \strong{streaming}: O(n^3) time, O(n) extra memory per thread. Computes ranks
on-demand for each row pair. Use only if "cached" causes memory issues.
}
}

\subsection{Parallelization}{

The mutual rank step uses OpenMP for parallel computation when available.
The correlation step uses Rfast::cora which is a fast C++ implementation.
}
}
\examples{
\dontrun{
# Load expression data
expr <- matrix(rnorm(1000 * 50), nrow = 1000, ncol = 50)
rownames(expr) <- paste0("Gene", 1:1000)

# Calculate similarity (returns TriSimilarity by default)
sim <- calculate_pcc_mr(expr)
print(sim)  # Shows memory savings

# Convert to full matrix if needed
sim_full <- as.matrix(sim)

# Or return full matrix directly (uses more memory)
sim_full <- calculate_pcc_mr(expr, return_tri = FALSE)

# For very large matrices with memory constraints, use streaming
sim <- calculate_pcc_mr(large_expr, mr_method = "streaming")

# Parallel with 4 cores
sim <- calculate_pcc_mr(expr, n_cores = 4)
}

}
\references{
Obayashi T, Kinoshita K (2009) Rank of correlation coefficient as a comparable
measure for biological significance of gene coexpression. DNA Research 16:249-260.

Grønvold L, Hvidsten TR. Cross species comparative transcriptomics using
co-expression networks.
}
