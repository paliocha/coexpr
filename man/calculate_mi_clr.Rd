% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/similarity.R
\name{calculate_mi_clr}
\alias{calculate_mi_clr}
\title{Calculate MI+CLR similarity matrix}
\usage{
calculate_mi_clr(
  expr_matrix,
  n_bins = 10,
  n_cores = 1,
  return_tri = TRUE,
  cache_dir = NULL
)
}
\arguments{
\item{expr_matrix}{Numeric matrix of gene expression (genes × samples).
Rows are genes, columns are samples. Should be log-transformed.}

\item{n_bins}{Integer. Number of bins for discretization. Default is 10.
More bins capture finer relationships but require more samples.}

\item{n_cores}{Integer. Number of cores for parallel computation via OpenMP.
Default is 1 (sequential).}

\item{return_tri}{Logical. If TRUE (default), returns a TriSimilarity object.
If FALSE, returns a full symmetric matrix.}

\item{cache_dir}{Character or NULL. If a directory path is provided, the
computed similarity matrix is cached to disk. On subsequent calls with
identical expression data and method parameters, the cached result is
loaded instead of recomputing. The directory is created automatically
if it doesn't exist. Default is NULL (no caching).}
}
\value{
If return_tri = TRUE (default), a TriSimilarity object (S4 class).
If return_tri = FALSE, a symmetric similarity matrix (genes × genes).
Values are non-negative (CLR transformation can produce values > 1).
}
\description{
Calculates co-expression similarity using mutual information (MI) followed by
context likelihood ratio (CLR) normalization. This is an alternative to PCC+MR
that was tested in Grønvold & Hvidsten. CLR helps address hub gene bias by
normalizing by the background distribution of MI values.
}
\details{
The computation is implemented in C++ with OpenMP parallelization for
efficient processing of large gene expression matrices.

The MI+CLR method:
\enumerate{
\item Discretizes expression values into equal-frequency bins
\item Calculates mutual information: MI(X,Y) = H(X) + H(Y) - H(X,Y)
\item Applies CLR transformation to normalize by background:
CLR_ij = sqrt(max(0, Z_row)^2 + max(0, Z_col)^2)
where Z_row and Z_col are z-scores of MI_ij within its row and column
}

The CLR transformation (Faith et al. 2007) reduces the bias from hub genes
that have high MI with many other genes.
\subsection{C++ Implementation}{

This function uses a fast C++ implementation with OpenMP parallelization:
\itemize{
\item Discretization: O(n * m log m) where n = genes, m = samples
\item MI computation: O(n^2 * m) for all pairwise comparisons
\item CLR transformation: O(n^2)
}

For a 1000-gene matrix with 100 samples, expect ~10-20x speedup compared
to pure R implementation when using 4 cores.
}

\subsection{Sample Requirements}{

MI estimation requires sufficient samples for reliable discretization.
A rule of thumb is at least 3 * n_bins samples. For 10 bins, this means
at least 30 samples.
}
}
\examples{
\dontrun{
# Calculate MI+CLR similarity
sim <- calculate_mi_clr(expr, n_bins = 10)

# Use with CCS calculation
ccs_results <- calculate_ccs(sim_sp1, sim_sp2, orthologs)

# Parallel computation with 4 cores
sim <- calculate_mi_clr(expr, n_bins = 10, n_cores = 4)
}

}
\references{
Faith JJ et al. (2007) Large-scale mapping and validation of Escherichia coli
transcriptional regulation from a compendium of expression profiles.
PLoS Biology 5:e8.

Grønvold L, Hvidsten TR. Cross species comparative transcriptomics using
co-expression networks.
}
