# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute average ranks for a vector (descending order)
#'
#' For each element, computes its rank when sorted in descending order.
#' Ties are handled using average ranks.
#'
#' @param x Input vector
#' @return Vector of ranks (1-based, average method for ties)
compute_ranks_desc_cpp <- function(x) {
    .Call(`_coexpr_compute_ranks_desc_cpp`, x)
}

#' Streaming mutual rank transformation (memory-efficient, parallelized)
#'
#' Transforms a Pearson correlation matrix into a PCC+MR similarity matrix
#' using the mutual rank normalization from Obayashi & Kinoshita (2009).
#'
#' This implementation uses a streaming approach that computes ranks on-demand
#' for each row pair, avoiding storage of intermediate rank matrices.
#' The algorithm is fully parallelizable via OpenMP.
#'
#' Memory usage: O(n^2) for input + O(n^2) for output + O(n) per thread
#' Time complexity: O(n^3) due to on-demand rank computation
#'
#' @param sim_pcc Symmetric Pearson correlation matrix (n x n)
#' @param n_cores Number of OpenMP threads to use (default: 1)
#' @return Mutual rank normalized similarity matrix (n x n) with values in range 0 to 1
#'
#' @details
#' The transformation is:
#' \deqn{S^{PCC+MR}_{ij} = 1 - \frac{\log(\sqrt{R_{ij} \cdot R_{ji}})}{\log(n)}}
#'
#' Where R_ij is the rank of gene j in gene i's correlation row (descending order).
#'
#' Since the input PCC matrix is symmetric, we exploit that colRanks(i,j) = rowRanks(j,i).
#' This means we only need to compute row ranks for each row.
#'
#' @export
mutual_rank_transform_cpp <- function(sim_pcc, n_cores = 1L) {
    .Call(`_coexpr_mutual_rank_transform_cpp`, sim_pcc, n_cores)
}

#' Cached mutual rank transformation (speed-optimized, parallelized)
#'
#' Transforms a Pearson correlation matrix into a PCC+MR similarity matrix
#' using the mutual rank normalization from Obayashi & Kinoshita (2009).
#'
#' This implementation precomputes all row ranks once, then uses them for
#' the mutual rank computation. This is faster than the streaming approach
#' but uses more memory (O(n^2) for the rank matrix).
#'
#' Memory usage: O(n^2) for input + O(n^2) for ranks + O(n^2) for output = 3 matrices
#' Time complexity: O(n^2 log n) for ranking + O(n^2) for transformation
#'
#' @param sim_pcc Symmetric Pearson correlation matrix (n x n)
#' @param n_cores Number of OpenMP threads to use (default: 1)
#' @return Mutual rank normalized similarity matrix (n x n) with values in range 0 to 1
#'
#' @details
#' Since the input PCC matrix is symmetric, column ranks equal transposed row ranks.
#' This allows us to precompute row ranks once and reuse them efficiently.
#'
#' @export
mutual_rank_transform_cached_cpp <- function(sim_pcc, n_cores = 1L) {
    .Call(`_coexpr_mutual_rank_transform_cached_cpp`, sim_pcc, n_cores)
}

#' Check if OpenMP is available
#'
#' @return TRUE if OpenMP support is compiled in, FALSE otherwise
#' @export
has_openmp <- function() {
    .Call(`_coexpr_has_openmp`)
}

#' Get maximum number of OpenMP threads
#'
#' @return Maximum number of threads available, or 1 if OpenMP not available
#' @export
get_max_threads <- function() {
    .Call(`_coexpr_get_max_threads`)
}

