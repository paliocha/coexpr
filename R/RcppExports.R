# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute entropy of a discrete variable
#'
#' @param x Integer vector of bin assignments
#' @param n_bins Number of possible bins
#' @return Entropy value in nats
NULL

#' Compute joint entropy of two discrete variables
#'
#' @param x First integer vector
#' @param y Second integer vector
#' @param n_bins Number of bins per variable
#' @return Joint entropy value in nats
NULL

#' Compute mutual information between two discrete variables
#'
#' MI(X,Y) = H(X) + H(Y) - H(X,Y)
#'
#' @param x First integer vector
#' @param y Second integer vector
#' @param n_bins Number of bins
#' @return Mutual information value in nats
NULL

#' Discretize a vector into equal-frequency bins
#'
#' @param x Numeric vector to discretize
#' @param n_bins Number of bins
#' @return Integer vector of bin assignments (0-indexed)
discretize_equalfreq_cpp <- function(x, n_bins) {
    .Call(`_coexpr_discretize_equalfreq_cpp`, x, n_bins)
}

#' Discretize expression matrix (all genes)
#'
#' @param expr Expression matrix (genes x samples)
#' @param n_bins Number of bins
#' @param n_cores Number of OpenMP threads (default 1)
#' @return Integer matrix of bin assignments (genes x samples)
discretize_matrix_cpp <- function(expr, n_bins, n_cores = 1L) {
    .Call(`_coexpr_discretize_matrix_cpp`, expr, n_bins, n_cores)
}

#' Compute mutual information matrix
#'
#' Computes pairwise MI for all gene pairs from discretized expression.
#'
#' @param expr_disc Discretized expression matrix (genes x samples, integer)
#' @param n_bins Number of bins used in discretization
#' @param n_cores Number of OpenMP threads
#' @return Symmetric MI matrix (genes x genes)
#'
#' @details
#' This function computes MI(i,j) = H(i) + H(j) - H(i,j) for all gene pairs.
#' The diagonal contains self-information (entropy).
#' Parallelized via OpenMP for efficiency.
#'
#' @export
compute_mi_matrix_cpp <- function(expr_disc, n_bins, n_cores = 1L) {
    .Call(`_coexpr_compute_mi_matrix_cpp`, expr_disc, n_bins, n_cores)
}

#' Apply CLR (Context Likelihood Ratio) transformation
#'
#' Normalizes MI matrix using z-scores to reduce hub gene bias.
#'
#' @param mi_matrix Symmetric mutual information matrix
#' @param n_cores Number of OpenMP threads (currently unused, for API consistency)
#' @return CLR-transformed matrix
#'
#' @details
#' CLR transformation (Faith et al. 2007):
#' \preformatted{
#' Z_row(i,j) = (MI(i,j) - mean(row_i)) / sd(row_i)
#' Z_col(i,j) = (MI(i,j) - mean(col_j)) / sd(col_j)
#' CLR(i,j) = sqrt(max(0, Z_row)^2 + max(0, Z_col)^2)
#' }
#'
#' @export
apply_clr_cpp <- function(mi_matrix, n_cores = 1L) {
    .Call(`_coexpr_apply_clr_cpp`, mi_matrix, n_cores)
}

#' Compute MI+CLR similarity matrix (triangular output)
#'
#' Full pipeline: discretize -> MI -> CLR, returning triangular format.
#'
#' @param expr Expression matrix (genes x samples)
#' @param n_bins Number of bins for discretization
#' @param n_cores Number of OpenMP threads
#' @return List with triangular similarity data
#'
#' @export
compute_mi_clr_tri_cpp <- function(expr, n_bins, n_cores = 1L) {
    .Call(`_coexpr_compute_mi_clr_tri_cpp`, expr, n_bins, n_cores)
}

#' Compute MI+CLR similarity matrix (full matrix output)
#'
#' Full pipeline: discretize -> MI -> CLR, returning full matrix.
#'
#' @param expr Expression matrix (genes x samples)
#' @param n_bins Number of bins for discretization
#' @param n_cores Number of OpenMP threads
#' @return CLR-transformed similarity matrix
#'
#' @export
compute_mi_clr_cpp <- function(expr, n_bins, n_cores = 1L) {
    .Call(`_coexpr_compute_mi_clr_cpp`, expr, n_bins, n_cores)
}

#' Compute average ranks for a vector (descending order)
#'
#' For each element, computes its rank when sorted in descending order.
#' Ties are handled using average ranks.
#'
#' @param x Input vector
#' @return Vector of ranks (1-based, average method for ties)
compute_ranks_desc_cpp <- function(x) {
    .Call(`_coexpr_compute_ranks_desc_cpp`, x)
}

#' Streaming mutual rank transformation (memory-efficient, parallelized)
#'
#' Transforms a Pearson correlation matrix into a PCC+MR similarity matrix
#' using the mutual rank normalization from Obayashi & Kinoshita (2009).
#'
#' This implementation uses a streaming approach that computes ranks on-demand
#' for each row pair, avoiding storage of intermediate rank matrices.
#' The algorithm is fully parallelizable via OpenMP.
#'
#' Memory usage: O(n^2) for input + O(n^2) for output + O(n) per thread
#' Time complexity: O(n^3) due to on-demand rank computation
#'
#' @param sim_pcc Symmetric Pearson correlation matrix (n x n)
#' @param n_cores Number of OpenMP threads to use (default: 1)
#' @return Mutual rank normalized similarity matrix (n x n) with values in range 0 to 1
#'
#' @details
#' The transformation is:
#' \deqn{S^{PCC+MR}_{ij} = 1 - \frac{\log(\sqrt{R_{ij} \cdot R_{ji}})}{\log(n)}}
#'
#' Where R_ij is the rank of gene j in gene i's correlation row (descending order).
#'
#' Since the input PCC matrix is symmetric, we exploit that colRanks(i,j) = rowRanks(j,i).
#' This means we only need to compute row ranks for each row.
#'
#' @export
mutual_rank_transform_cpp <- function(sim_pcc, n_cores = 1L) {
    .Call(`_coexpr_mutual_rank_transform_cpp`, sim_pcc, n_cores)
}

#' Cached mutual rank transformation (speed-optimized, parallelized)
#'
#' Transforms a Pearson correlation matrix into a PCC+MR similarity matrix
#' using the mutual rank normalization from Obayashi & Kinoshita (2009).
#'
#' This implementation precomputes all row ranks once, then uses them for
#' the mutual rank computation. This is faster than the streaming approach
#' but uses more memory (O(n^2) for the rank matrix).
#'
#' Memory usage: O(n^2) for input + O(n^2) for ranks + O(n^2) for output = 3 matrices
#' Time complexity: O(n^2 log n) for ranking + O(n^2) for transformation
#'
#' @param sim_pcc Symmetric Pearson correlation matrix (n x n)
#' @param n_cores Number of OpenMP threads to use (default: 1)
#' @return Mutual rank normalized similarity matrix (n x n) with values in range 0 to 1
#'
#' @details
#' Since the input PCC matrix is symmetric, column ranks equal transposed row ranks.
#' This allows us to precompute row ranks once and reuse them efficiently.
#'
#' @export
mutual_rank_transform_cached_cpp <- function(sim_pcc, n_cores = 1L) {
    .Call(`_coexpr_mutual_rank_transform_cached_cpp`, sim_pcc, n_cores)
}

#' Check if OpenMP is available
#'
#' @return TRUE if OpenMP support is compiled in, FALSE otherwise
#' @export
has_openmp <- function() {
    .Call(`_coexpr_has_openmp`)
}

#' Get maximum number of OpenMP threads
#'
#' @return Maximum number of threads available, or 1 if OpenMP not available
#' @export
get_max_threads <- function() {
    .Call(`_coexpr_get_max_threads`)
}

#' Cached mutual rank transformation returning triangular format
#'
#' Transforms a Pearson correlation matrix into a PCC+MR similarity matrix
#' and returns only the upper triangle (excluding diagonal) for memory efficiency.
#' This reduces storage by approximately 50%.
#'
#' The upper triangle is returned in column-major order, which matches R's
#' upper.tri() ordering. For a matrix with n genes, the returned vector has
#' n*(n-1)/2 elements.
#'
#' @param sim_pcc Symmetric Pearson correlation matrix (n x n)
#' @param n_cores Number of OpenMP threads to use (default: 1)
#' @return List with components:
#'   - data: numeric vector of upper triangle values (column-major, excluding diagonal)
#'   - n: number of genes
#'   - diag_value: diagonal value (always 1.0 for PCC+MR)
#'
#' @details
#' The transformation is the same as mutual_rank_transform_cached_cpp:
#' \deqn{S^{PCC+MR}_{ij} = 1 - \frac{\log(\sqrt{R_{ij} \cdot R_{ji}})}{\log(n)}}
#'
#' The upper triangle extraction follows column-major order:
#' For positions (i,j) with i < j, elements are ordered by increasing j,
#' then by increasing i within each column.
#'
#' @export
mutual_rank_transform_tri_cpp <- function(sim_pcc, n_cores = 1L) {
    .Call(`_coexpr_mutual_rank_transform_tri_cpp`, sim_pcc, n_cores)
}

